(function(global){
  "use strict";

  const CountSystems = {
    HILO: {
      name: "Hi-Lo",
      weights: {
        "2": 1, "3": 1, "4": 1, "5": 1, "6": 1,
        "7": 0, "8": 0, "9": 0,
        "T": -1, "J": -1, "Q": -1, "K": -1, "A": -1
      },
      decimals: 0
    },
    HALVES: {
      name: "Wong Halves",
      weights: {
        "2": 0.5, "3": 1, "4": 1, "5": 1.5, "6": 1,
        "7": 0.5, "8": 0, "9": -0.5,
        "T": -1, "J": -1, "Q": -1, "K": -1, "A": -1
      },
      decimals: 1
    },
    HIOPT2: {
      name: "Hi-Opt II (Ace-neutral)",
      weights: {
        "2": 1, "3": 1, "4": 2, "5": 2, "6": 1,
        "7": 1, "8": 0, "9": 0,
        "T": -2, "J": -2, "Q": -2, "K": -2, "A": 0
      },
      decimals: 0
    }
  };

  function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
  function roundTo(x, decimals){
    const p = Math.pow(10, decimals);
    return Math.round(x * p) / p;
  }

  function normalizeCard(c){
    if(!c) return null;
    const s = String(c).trim().toUpperCase();
    if(s === "10") return "T";
    if(["A","2","3","4","5","6","7","8","9","T","J","Q","K"].includes(s)) return s;
    return null;
  }

  function cardsPerDeck(){ return 52; }

  function decksRemainingFromSeen(decksInShoe, cardsSeen){
    const total = decksInShoe * cardsPerDeck();
    const remCards = clamp(total - cardsSeen, 0, total);
    const remDecks = remCards / cardsPerDeck();
    return clamp(remDecks, 0.25, decksInShoe);
  }

  // Conservative edge approximation, intentionally capped.
  function estimateEdgePct(tc, penetration){
    const slope = 0.45; // percent per TC
    const cap = 3.0;
    const floor = -2.0;
    const penAdj = clamp(0.55 + 0.60 * penetration, 0.55, 1.15);
    const raw = tc * slope * penAdj;
    return clamp(raw, floor, cap);
  }

  // Conservative fractional Kelly mapping.
  function suggestBetUnits(edgePct, bankrollUnits, kellyCapFrac){
    const edge = edgePct / 100;
    const variance = 1.30;
    const kelly = edge / variance;
    if(kelly <= 0) return 1;

    const f = clamp(kelly, 0, kellyCapFrac);
    const units = Math.max(1, Math.round(f * bankrollUnits));
    const hardCap = Math.max(1, Math.round(0.10 * bankrollUnits));
    return clamp(units, 1, hardCap);
  }

  function cardValue(c){
    if(c === "A") return 11;
    if(c === "T" || c === "J" || c === "Q" || c === "K") return 10;
    return Number(c);
  }

  function handInfo(cards){
    let total = 0;
    let aceCount = 0;
    for(const c of cards){
      total += cardValue(c);
      if(c === "A") aceCount += 1;
    }
    while(total > 21 && aceCount > 0){
      total -= 10;
      aceCount -= 1;
    }

    // soft if at least one ace is still counted as 11
    // compute by checking if any ace could remain 11 after reductions
    let raw = 0;
    let a = 0;
    for(const c of cards){
      raw += cardValue(c);
      if(c === "A") a += 1;
    }
    while(raw > 21 && a > 0){
      raw -= 10;
      a -= 1;
    }
    const soft = a > 0;

    const isPair = cards.length === 2 && normalizeCard(cards[0]) === normalizeCard(cards[1]);
    const pairRank = isPair ? normalizeCard(cards[0]) : null;
    return { total, soft, isPair, pairRank };
  }

  function dealerUpValue(c){
    if(!c) return null;
    if(c === "J" || c === "Q" || c === "K") return "T";
    return c;
  }

  // Basic strategy: 6D, S17, DAS, LS (late surrender)
  // Actions: H,S,D,P,R
  function basicStrategy(playerCards, dealerUp, rules){
    const up = dealerUpValue(dealerUp);
    if(!up) return { action: null, reason: "Set dealer upcard" };
    if(playerCards.length < 2) return { action: null, reason: "Add player cards" };

    const info = handInfo(playerCards);
    const allowLS = !!rules.lateSurrender;

    // Pair rules
    if(info.isPair){
      const p = info.pairRank;

      if(p === "A") return { action: "P", reason: "Pair AA" };
      if(p === "8") return { action: "P", reason: "Pair 88" };
      if(p === "T") return { action: "S", reason: "Pair TT" };

      if(p === "9"){
        if(["2","3","4","5","6","8","9"].includes(up)) return { action: "P", reason: "Pair 99" };
        return { action: "S", reason: "Pair 99" };
      }

      if(p === "7"){
        if(["2","3","4","5","6","7"].includes(up)) return { action: "P", reason: "Pair 77" };
        return { action: "H", reason: "Pair 77" };
      }

      if(p === "6"){
        if(["2","3","4","5","6"].includes(up)) return { action: "P", reason: "Pair 66" };
        return { action: "H", reason: "Pair 66" };
      }

      if(p === "5"){
        if(["2","3","4","5","6","7","8","9"].includes(up)) return { action: "D", reason: "Pair 55 (play as 10)" };
        return { action: "H", reason: "Pair 55" };
      }

      if(p === "4"){
        if(!!rules.doubleAfterSplit && ["5","6"].includes(up)) return { action: "P", reason: "Pair 44 (DAS)" };
        return { action: "H", reason: "Pair 44" };
      }

      if(p === "3" || p === "2"){
        if(["2","3","4","5","6","7"].includes(up)) return { action: "P", reason: `Pair ${p}${p}` };
        return { action: "H", reason: `Pair ${p}${p}` };
      }
      // fallthrough
    }

    // Soft totals
    if(info.soft){
      const t = info.total;

      if(t === 13 || t === 14){
        if(["5","6"].includes(up)) return { action: "D", reason: `Soft ${t}` };
        return { action: "H", reason: `Soft ${t}` };
      }
      if(t === 15 || t === 16){
        if(["4","5","6"].includes(up)) return { action: "D", reason: `Soft ${t}` };
        return { action: "H", reason: `Soft ${t}` };
      }
      if(t === 17){
        if(["3","4","5","6"].includes(up)) return { action: "D", reason: "Soft 17" };
        return { action: "H", reason: "Soft 17" };
      }
      if(t === 18){
        if(["3","4","5","6"].includes(up)) return { action: "D", reason: "Soft 18" };
        if(["2","7","8"].includes(up)) return { action: "S", reason: "Soft 18" };
        return { action: "H", reason: "Soft 18" };
      }
      if(t >= 19) return { action: "S", reason: `Soft ${t}` };
      return { action: "H", reason: `Soft ${t}` };
    }

    // Hard totals
    const t = info.total;

    if(allowLS){
      if(t === 16 && ["9","T","A"].includes(up)) return { action: "R", reason: "LS 16 vs 9/T/A" };
      if(t === 15 && up === "T") return { action: "R", reason: "LS 15 vs T" };
    }

    if(t <= 8) return { action: "H", reason: `Hard ${t}` };
    if(t === 9){
      if(["3","4","5","6"].includes(up)) return { action: "D", reason: "Hard 9" };
      return { action: "H", reason: "Hard 9" };
    }
    if(t === 10){
      if(["2","3","4","5","6","7","8","9"].includes(up)) return { action: "D", reason: "Hard 10" };
      return { action: "H", reason: "Hard 10" };
    }
    if(t === 11){
      return { action: "D", reason: "Hard 11" };
    }
    if(t === 12){
      if(["4","5","6"].includes(up)) return { action: "S", reason: "Hard 12" };
      return { action: "H", reason: "Hard 12" };
    }
    if(t >= 13 && t <= 16){
      if(["2","3","4","5","6"].includes(up)) return { action: "S", reason: `Hard ${t}` };
      return { action: "H", reason: `Hard ${t}` };
    }
    return { action: "S", reason: `Hard ${t}` };
  }

  // Hi-Lo deviations subset, applies only when system=HILO and enabled.
  // Action override only when TC >= index.
  const HiLoDeviations = [
    { key: "HARD:16vT", tcMin: 0, action: "S", label: "16 vs T stand at TC >= 0" },
    { key: "HARD:15vT", tcMin: 4, action: "S", label: "15 vs T stand at TC >= 4" },
    { key: "HARD:12v3", tcMin: 2, action: "S", label: "12 vs 3 stand at TC >= 2" },
    { key: "HARD:12v2", tcMin: 3, action: "S", label: "12 vs 2 stand at TC >= 3" },
    { key: "HARD:10vT", tcMin: 4, action: "D", label: "10 vs T double at TC >= 4" },
    { key: "HARD:11vA", tcMin: 1, action: "D", label: "11 vs A double at TC >= 1" },
    { key: "HARD:9v2",  tcMin: 1, action: "D", label: "9 vs 2 double at TC >= 1" },
    { key: "HARD:9v7",  tcMin: 3, action: "D", label: "9 vs 7 double at TC >= 3" }
  ];

  function deviationKey(playerCards, dealerUp){
    const up = dealerUpValue(dealerUp);
    if(!up || playerCards.length < 2) return null;
    const info = handInfo(playerCards);
    if(info.soft || info.isPair) return null;
    return `HARD:${info.total}v${up}`;
  }

  function applyDeviations(base, playerCards, dealerUp, tc, system, enabled){
    if(!enabled) return { ...base, usedDeviation: false };
    if(system !== "HILO") return { ...base, usedDeviation: false };
    const key = deviationKey(playerCards, dealerUp);
    if(!key) return { ...base, usedDeviation: false };

    for(const d of HiLoDeviations){
      if(d.key === key && tc >= d.tcMin){
        return { action: d.action, reason: `Deviation: ${d.label}`, usedDeviation: true };
      }
    }
    return { ...base, usedDeviation: false };
  }

  class BJEngine {
    constructor(opts = {}){
      this.resetAll();

      this.settings = {
        system: opts.system || "HILO",
        decksInShoe: opts.decksInShoe || 6,
        tcMode: opts.tcMode || "SIM",
        trayDecksRemaining: opts.trayDecksRemaining || (opts.decksInShoe || 6),
        bankrollUnits: opts.bankrollUnits || 200,
        kellyCapFrac: typeof opts.kellyCapFrac === "number" ? opts.kellyCapFrac : 0.25,

        // rules defaults
        dealerHitsSoft17: false, // S17
        doubleAfterSplit: true,  // DAS
        lateSurrender: true,     // LS

        useDeviations: false
      };
    }

    resetAll(){
      this.rc = 0;
      this.cardsSeen = 0;
      this.history = [];
      this.player = [];
      this.dealer = [];
    }

    resetCountsOnly(){
      this.rc = 0;
      this.cardsSeen = 0;
      this.history = [];
    }

    clearHand(){
      this.player = [];
      this.dealer = [];
    }

    newHand(){
      this.clearHand();
    }

    setSettings(patch){
      this.settings = { ...this.settings, ...patch };

      this.settings.decksInShoe = clamp(Number(this.settings.decksInShoe || 6), 1, 8);
      this.settings.trayDecksRemaining = clamp(
        Number(this.settings.trayDecksRemaining || this.settings.decksInShoe),
        0.25,
        this.settings.decksInShoe
      );
      this.settings.bankrollUnits = clamp(Number(this.settings.bankrollUnits || 200), 10, 100000);
      this.settings.kellyCapFrac = clamp(Number(this.settings.kellyCapFrac || 0.25), 0.05, 0.50);

      if(!CountSystems[this.settings.system]) this.settings.system = "HILO";
      if(!["SIM","CASINO"].includes(this.settings.tcMode)) this.settings.tcMode = "SIM";
    }

    getSystem(){
      return CountSystems[this.settings.system] || CountSystems.HILO;
    }

    weightFor(card){
      const sys = this.getSystem();
      return sys.weights[card] ?? 0;
    }

    addSeenCard(cardInput){
      const card = normalizeCard(cardInput);
      if(!card) return { ok: false, error: "Invalid card" };

      const delta = this.weightFor(card);
      this.rc += delta;
      this.cardsSeen += 1;
      this.history.push({ card, delta });

      return { ok: true, card };
    }

    addCardToPlayer(cardInput){
      const res = this.addSeenCard(cardInput);
      if(!res.ok) return res;
      this.player.push(res.card);
      return { ok: true };
    }

    addCardToDealer(cardInput){
      const res = this.addSeenCard(cardInput);
      if(!res.ok) return res;
      this.dealer.push(res.card);
      return { ok: true };
    }

    undo(){
      const last = this.history.pop();
      if(!last) return { ok: false, error: "Nothing to undo" };

      this.rc -= last.delta;
      this.cardsSeen = Math.max(0, this.cardsSeen - 1);

      const pTop = this.player[this.player.length - 1];
      if(pTop === last.card){
        this.player.pop();
        return { ok: true };
      }
      const dTop = this.dealer[this.dealer.length - 1];
      if(dTop === last.card){
        this.dealer.pop();
        return { ok: true };
      }
      return { ok: true };
    }

    shuffle(){
      this.resetCountsOnly();
      this.clearHand();
      return { ok: true };
    }

    decksRemaining(){
      const decksInShoe = Number(this.settings.decksInShoe || 6);
      if(this.settings.tcMode === "CASINO"){
        return clamp(Number(this.settings.trayDecksRemaining || decksInShoe), 0.25, decksInShoe);
      }
      return decksRemainingFromSeen(decksInShoe, this.cardsSeen);
    }

    penetration(){
      const decksInShoe = Number(this.settings.decksInShoe || 6);
      const totalCards = decksInShoe * cardsPerDeck();
      const dealt = clamp(this.cardsSeen, 0, totalCards);
      return dealt / totalCards;
    }

    trueCount(){
      const sys = this.getSystem();
      const decksRem = this.decksRemaining();
      const tc = this.rc / decksRem;
      return roundTo(tc, sys.decimals === 0 ? 1 : 2);
    }

    edgePct(){
      const tc = this.trueCount();
      const pen = this.penetration();
      return roundTo(estimateEdgePct(tc, pen), 1);
    }

    betUnits(){
      const e = this.edgePct();
      return suggestBetUnits(e, this.settings.bankrollUnits, this.settings.kellyCapFrac);
    }

    recommendation(){
      const dealerUp = this.dealer[0] || null;
      const base = basicStrategy(this.player, dealerUp, this.settings);
      if(!base.action) return { action: null, reason: base.reason, usedDeviation: false };

      const tc = this.trueCount();
      const out = applyDeviations(base, this.player, dealerUp, tc, this.settings.system, !!this.settings.useDeviations);
      return { action: out.action, reason: out.reason || base.reason, usedDeviation: !!out.usedDeviation };
    }

    snapshot(){
      const sys = this.getSystem();
      const decksRem = this.decksRemaining();
      const dealerUp = this.dealer[0] || null;
      const pInfo = this.player.length ? handInfo(this.player) : null;

      return {
        settings: { ...this.settings },
        systemName: sys.name,
        rc: roundTo(this.rc, sys.decimals),
        cardsSeen: this.cardsSeen,
        decksRemaining: roundTo(decksRem, 2),
        penetration: roundTo(this.penetration(), 4),
        tc: this.trueCount(),
        edgePct: this.edgePct(),
        betUnits: this.betUnits(),
        hand: {
          dealerUp,
          playerCards: [...this.player],
          playerInfo: pInfo
        },
        rec: this.recommendation()
      };
    }

    exportJSON(){
      return JSON.stringify({
        v: 3,
        state: {
          rc: this.rc,
          cardsSeen: this.cardsSeen,
          history: this.history,
          player: this.player,
          dealer: this.dealer
        },
        settings: this.settings
      }, null, 2);
    }

    importJSON(jsonText){
      let obj;
      try{ obj = JSON.parse(jsonText); }catch(e){ return { ok: false, error: "Invalid JSON" }; }
      if(!obj || !obj.state || !obj.settings) return { ok: false, error: "Missing fields" };

      const st = obj.state;
      this.rc = Number(st.rc || 0);
      this.cardsSeen = Number(st.cardsSeen || 0);
      this.history = Array.isArray(st.history) ? st.history : [];
      this.player = Array.isArray(st.player) ? st.player : [];
      this.dealer = Array.isArray(st.dealer) ? st.dealer : [];

      this.setSettings(obj.settings);
      return { ok: true };
    }
  }

  global.BJEngine = BJEngine;
  global.BJCountSystems = CountSystems;

})(window);
